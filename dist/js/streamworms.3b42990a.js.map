{"version":3,"file":"js/streamworms.3b42990a.js","mappings":"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","sources":["webpack://@zephsinx/streamworms/./src/streamworms/js/utils/constants.js","webpack://@zephsinx/streamworms/./src/streamworms/js/utils/utils.js","webpack://@zephsinx/streamworms/./src/streamworms/js/streamworms.js"],"sourcesContent":["// streamworms constants.\r\nconst DefaultMinMinutes = 30;\r\nconst DefaultMaxMinutes = 90;\r\n\r\nconst DefaultMaxHeight = \"25\"; // Percentage value\r\nconst DefaultMaxWidth = \"25\"; // Percentage value\r\n\r\n// Warning messages\r\nconst ZeroMediaDurationWarning = \"Unable to calculate media duration for the requested media. Please set the media duration (in seconds) via the `mediaDuration` parameter. Parameter supports decimal values.\";\r\n\r\n// Error messages\r\nconst ContentTypeNotFoundError = \"Unable to determine content type of from media URL. Defaulting to `img` tag\";\r\nconst ContentTypeNotSupportedError = \"Content type not yet supported. Defaulting to `img` tag\\\". Content type found: `{0}`\";\r\nconst FetchImageError = \"Error fetching image from URL '{0}'. Error status: '{1}'\";\r\n\r\nexport default Object.freeze({\r\n    DefaultMinMinutes: DefaultMinMinutes,\r\n    DefaultMaxMinutes: DefaultMaxMinutes,\r\n    DefaultMaxHeight: DefaultMaxHeight,\r\n    DefaultMaxWidth: DefaultMaxWidth,\r\n    ZeroMediaDurationWarning: ZeroMediaDurationWarning,\r\n    ContentTypeNotFoundError: ContentTypeNotFoundError,\r\n    ContentTypeNotSupportedError: ContentTypeNotSupportedError,\r\n    FetchImageError: FetchImageError,\r\n});","ï»¿/*\r\n1. There are 4 quadrants (0-3)\r\n   - Quadrants are numbered left to right, top to bottom, as such:\r\n       | 0 | 1 |\r\n       | 2 | 3 |\r\n   - Evens on the left, odds on the right\r\n2. Each quadrant is window.innerWidth * 0.25 in width and window.innerHeight * 0.25 in height\r\n3. Pick a quadrant (0-3) via random int\r\n   - Should be different to the previous quadrant\r\n4. Generate random x and y coordinates within the quadrant size\r\n    - If odd quadrant, recalculate quadrant x if quadrant x + mediaWidth > quadrantWidth\r\n    - If quadrant > 1, recalculate quadrant y if quadrant y + mediaHeight > quadrantHeight\r\n5. Set the media x and y coordinates\r\n   - If odd quadrant, x = (window.innerWidth * 0.5) + quadrant x\r\n   - If even quadrant, x = quadrant x\r\n   - If quadrant > 1, y = window.innerHeight * 0.5 + quadrant y\r\n   - If quadrant < 1, y = quadrant y\r\n*/\r\nconst getMediaCoordinateStyles = function (lastQuadrant, mediaHeight, mediaWidth) {\r\n    let x;\r\n    let y;\r\n    let quadrantX;\r\n    let quadrantY;\r\n    let newQuadrant;\r\n\r\n    let windowHeight = window.innerHeight;\r\n    let windowWidth = window.innerWidth;\r\n    let quadrantHeight = windowHeight * 0.5;\r\n    let quadrantWidth = windowWidth * 0.5;\r\n\r\n    // Pick random quadrant, different to the previous\r\n    do {\r\n        newQuadrant = Math.floor(Math.random() * 4);\r\n    } while (newQuadrant === lastQuadrant);\r\n\r\n    // Pick a random value for media x, ensuring the image remains on-screen\r\n    do {\r\n        quadrantX = Math.floor(Math.random() * quadrantWidth);\r\n    } while (quadrantX + mediaWidth > quadrantWidth);\r\n\r\n    // Pick a random value for media y, ensuring the image remains on-screen\r\n    do {\r\n        quadrantY = Math.floor(Math.random() * quadrantHeight);\r\n    } while (quadrantY + mediaHeight > quadrantHeight);\r\n\r\n    x = newQuadrant % 2 === 0 ? quadrantX : quadrantWidth + quadrantX;\r\n    y = newQuadrant < 2 ? quadrantY : quadrantHeight + quadrantY;\r\n\r\n    return {quadrant: newQuadrant, left: `${x}px`, top: `${y}px`};\r\n}\r\n\r\n// Returns a random integer between min and max (inclusive)\r\nconst randomIntFromInterval = function (min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min)\r\n}\r\n\r\n\r\nexport default {\r\n    getMediaCoordinateStyles: getMediaCoordinateStyles,\r\n    randomIntFromInterval: randomIntFromInterval,\r\n};\r\n","\"use strict\";\r\n\r\nimport constants from \"./utils/constants.js\";\r\nimport utils from \"./utils/utils.js\";\r\n// Global defaults\r\n\r\nconst defaultMinMillis = constants.DefaultMinMinutes * 60 * 1000;\r\nconst defaultMaxMillis = constants.DefaultMaxMinutes * 60 * 1000;\r\nconst defaultMediaUrl = '/media/worms.gif';\r\n\r\n// Div containing the media to display\r\nconst mediaDiv = document.getElementById(\"media-div\");\r\n\r\n// Global variables\r\n\r\nlet lastQuadrant;\r\nlet tagName;\r\nlet element;\r\nlet config;\r\nlet first = true;\r\n\r\n// Get config settings\r\ngetStreamWormsConfig()\r\n    .then(configVal => {\r\n        config = configVal;\r\n        tagName = getTagNameFromFile(config.contentType);\r\n        element = prepareElement(tagName, config);\r\n    })\r\n    .then(() => {\r\n        // Create and append media element to media div\r\n        mediaDiv.appendChild(element);\r\n        playMedia(element);\r\n    });\r\n\r\n//#region Media Methods\r\n\r\n// Shows and plays media after a random delay, then hides the media after durationMillis expires\r\nfunction playMedia(element) {\r\n    let delay = utils.randomIntFromInterval(config.minDelay, config.maxDelay);\r\n    if (first) {\r\n        delay = 0;\r\n        first = false;\r\n    }\r\n    // Display the image after the random delay expires\r\n    setTimeout(() => {\r\n        // Reset image source to replay in the case of a GIF\r\n        if (tagName === 'img') {\r\n            element.src = '';\r\n            element.src = config.mediaUrl;\r\n        }\r\n        // Restart video and play in the case of a WebM\r\n        else {\r\n            element.currentTime = 0;\r\n            element.play();\r\n        }\r\n        // Make media visible\r\n        mediaDiv.style.visibility = 'visible';\r\n\r\n        // Hide image/video after it plays for the desired duration, and requeue the media timer\r\n        setTimeout(() => {\r\n            mediaDiv.style.visibility = 'hidden';\r\n            setPosition(element);\r\n            playMedia(element);\r\n        }, config.mediaDuration);\r\n    }, delay);\r\n}\r\n\r\n// Set position of media element on page\r\nfunction setPosition(element) {\r\n    let coordinates = utils.getMediaCoordinateStyles(lastQuadrant, element.height, element.width);\r\n    lastQuadrant = coordinates.quadrant;\r\n    element.style.left = coordinates.left;\r\n    element.style.top = coordinates.top;\r\n}\r\n\r\n//#endregion\r\n\r\n//#region StreamWorms configuration methods\r\n\r\n// Parse URL parameters from URL\r\nasync function getStreamWormsConfig() {\r\n    // Get parameters from browser URL\r\n    let urlParams = new Proxy(new URLSearchParams(window.location.search), {\r\n        get: (searchParams, prop) => searchParams.get(prop || ''),\r\n    });\r\n\r\n    let skipDelay = parseBool(urlParams.skipDelay);\r\n    let maxDelayMillis = getDelayMillis(skipDelay, urlParams.max, defaultMaxMillis);\r\n    let minDelayMillis = getDelayMillis(skipDelay, urlParams.min, defaultMinMillis);\r\n    let maxHeight = isValidNumericValue(urlParams.maxHeight) ? urlParams.maxHeight : constants.DefaultMaxHeight;\r\n    let maxWidth = isValidNumericValue(urlParams.maxWidth) ? urlParams.maxWidth : constants.DefaultMaxWidth;\r\n    let mediaUrl = await getMediaUrl(urlParams.mediaUrl);\r\n    let mediaInfo = await fetchMediaInfo(mediaUrl);\r\n    let mediaDuration = isValidNumericValue(urlParams.mediaDuration) ? (urlParams.mediaDuration * 1000) : mediaInfo.duration || 0;\r\n\r\n    let config = {\r\n        skipDelay: skipDelay,\r\n        maxDelay: maxDelayMillis,            // The maximum delay between media plays (ignored if skipDelay is true)\r\n        minDelay: minDelayMillis,            // The minimum delay between media plays (ignored if skipDelay is true)\r\n        maxHeight: maxHeight,                // The maximum height the media should take up. Image will be resized to fit if larger\r\n        maxWidth: maxWidth,                  // The maximum width the media should take up. Image will be resized to fit if larger\r\n        mediaUrl: mediaUrl,                  // The URL or path of the media to display\r\n        mediaDuration: mediaDuration,        // The duration of the media to display, used for knowing how long to display it for. In milliseconds\r\n        contentType: mediaInfo.contentType,  // Content type of the downloaded media\r\n    };\r\n\r\n    return validateConfig(config);\r\n}\r\n\r\nasync function getMediaUrl(urlParamMediaUrl) {\r\n    if (urlParamMediaUrl) {\r\n        return urlParamMediaUrl;\r\n    }\r\n    \r\n    // Fetch media file\r\n    let mediaFile = await fetch('/js/resources/media.json', {mode: 'cors'})\r\n        .then(res => {\r\n            if (res.ok) {\r\n                return res.json();\r\n            }\r\n            return Promise.reject(res);\r\n        })\r\n        .catch((err) => {\r\n            console.log(err);\r\n        });\r\n    \r\n    return mediaFile.mediaPath || defaultMediaUrl;\r\n}\r\n\r\n// Validate and update config if invalid.\r\nfunction validateConfig(config) {\r\n    // minDelayMillis must be less than or equal to maxDelayMillis, else use defaults\r\n    if (config.maxDelayMillis < config.minDelayMillis) {\r\n        config.maxDelayMillis = defaultMaxMillis;\r\n        config.minDelayMillis = defaultMinMillis;\r\n    }\r\n\r\n    if (config.mediaDuration === 0) {\r\n        throw new Error(constants.ZeroMediaDurationWarning);\r\n    }\r\n\r\n    return config;\r\n}\r\n\r\n// Validate and calculate delay in milliseconds from params\r\nfunction getDelayMillis(skipDelay, delayMinutes, defaultDelay) {\r\n    if (skipDelay)\r\n        return 0;\r\n\r\n    return isValidNumericValue(delayMinutes) ? (delayMinutes * 60 * 1000) : defaultDelay;\r\n}\r\n\r\n// Check that provided string is a valid number and positive\r\nfunction isValidNumericValue(numberString) {\r\n    return !isNaN(numberString) && !isNaN(parseFloat(numberString)) && parseFloat(numberString) > 0;\r\n}\r\n\r\n// Returns the value of a string as a boolean. Defaults to \"false\" if not a valid boolean\r\nfunction parseBool(boolString) {\r\n    return boolString === 'true';\r\n}\r\n\r\n// Fetch media file\r\nasync function fetchMediaInfo(mediaUrl) {\r\n    let contentType;\r\n    let duration = await fetch(mediaUrl, {mode: 'cors'})\r\n        .then(res => {\r\n            if (res.ok) {\r\n                {\r\n                    contentType = res.headers.get(\"Content-Type\");\r\n                    return Promise.resolve(res);\r\n                }\r\n            }\r\n            return Promise.reject(res);\r\n        })\r\n        .then(res => res.arrayBuffer())\r\n        .then(ab => getMediaDuration(new Uint8Array(ab)))\r\n        .catch(err => {\r\n            throw new Error(constants.FetchImageError.replace('{0}', mediaUrl).replace('{1}', `${err.status} - ${err.statusText}`));\r\n        });\r\n\r\n    return {contentType: contentType, duration: duration};\r\n}\r\n\r\n// Fancy method to get Media length\r\nfunction getMediaDuration(uint8) {\r\n    let duration = 0;\r\n    for (let i = 0, len = uint8.length; i < len; i++) {\r\n        if (uint8[i] === 0x21\r\n            && uint8[i + 1] === 0xF9\r\n            && uint8[i + 2] === 0x04\r\n            && uint8[i + 7] === 0x00) {\r\n            const delay = (uint8[i + 5] << 8) | (uint8[i + 4] & 0xFF)\r\n            duration += delay < 2 ? 10 : delay\r\n        }\r\n    }\r\n    // Convert to milliseconds\r\n    return duration * 10\r\n}\r\n\r\n//#endregion\r\n\r\n//#region Element Configuration\r\n\r\n// Configure element to display based on tagName\r\nfunction prepareElement(tagName, config) {\r\n    // Create img or video element based on tagName\r\n    let mediaElement = document.createElement(tagName);\r\n    mediaElement.id = 'rendered-media';\r\n    mediaElement.style.objectFit = 'contain';\r\n    mediaElement.style.maxHeight = config.maxHeight + '%';\r\n    mediaElement.style.maxWidth = config.maxWidth + '%';\r\n    mediaElement.style.position = 'absolute';\r\n    mediaElement.style.top = '0';\r\n    mediaElement.style.left = '0';\r\n    mediaElement.alt = 'Just a lil\\' worm guy';\r\n\r\n    switch (tagName) {\r\n        case 'img':\r\n            return mediaElement;\r\n        case 'video':\r\n            return configureVideoElement(mediaElement, config);\r\n        default:\r\n            throw new Error(`Tag name ${tagName} not recognized`);\r\n    }\r\n}\r\n\r\n// Get the appropriate element tag name from the media file extension\r\nfunction getTagNameFromFile(contentType) {\r\n    switch (contentType) {\r\n        case 'image/avif':\r\n        case 'image/gif':\r\n        case 'image/jpeg':\r\n        case 'image/png':\r\n        case 'image/svg+xml':\r\n        case 'image/webp':\r\n        case contentType.startsWith('image/'):\r\n            return 'img';\r\n        case 'video/webm':\r\n        case contentType.startsWith('video/'):\r\n            return 'video';\r\n        default: {\r\n            if (!contentType)\r\n                console.warn(constants.ContentTypeNotFoundError);\r\n            else\r\n                console.warn(constants.ContentTypeNotSupportedError.replace('{0}', contentType));\r\n        }\r\n            return 'img';\r\n    }\r\n}\r\n\r\n// Set Video properties\r\nfunction configureVideoElement(videoElement, config) {\r\n    let videoSource = document.createElement('source');\r\n    videoSource.src = config.mediaUrl;\r\n    videoSource.type = config.contentType;\r\n\r\n    // Note: autoplay only works in Chrome after a user has interacted with the DOM unless the muted tag is used\r\n    videoElement.autoplay = true;\r\n    videoElement.appendChild(videoSource);\r\n\r\n    return videoElement;\r\n}\r\n\r\n//#endregion"],"names":["Object","freeze","DefaultMinMinutes","DefaultMaxMinutes","DefaultMaxHeight","DefaultMaxWidth","ZeroMediaDurationWarning","ContentTypeNotFoundError","ContentTypeNotSupportedError","FetchImageError","getMediaCoordinateStyles","lastQuadrant","mediaHeight","mediaWidth","x","y","quadrantX","quadrantY","newQuadrant","quadrantHeight","window","innerHeight","quadrantWidth","innerWidth","Math","floor","random","quadrant","left","top","randomIntFromInterval","min","max","defaultMinMillis","constants","defaultMaxMillis","mediaDiv","document","getElementById","tagName","config","first","playMedia","element","delay","utils","minDelay","maxDelay","setTimeout","src","mediaUrl","currentTime","play","style","visibility","coordinates","height","width","setPosition","mediaDuration","getDelayMillis","skipDelay","delayMinutes","defaultDelay","isValidNumericValue","numberString","isNaN","parseFloat","async","urlParams","Proxy","URLSearchParams","location","search","get","searchParams","prop","maxDelayMillis","minDelayMillis","maxHeight","maxWidth","urlParamMediaUrl","fetch","mode","then","res","ok","json","Promise","reject","catch","err","console","log","mediaPath","getMediaUrl","mediaInfo","contentType","duration","headers","resolve","arrayBuffer","ab","uint8","i","len","length","getMediaDuration","Uint8Array","Error","replace","status","statusText","fetchMediaInfo","validateConfig","getStreamWormsConfig","configVal","startsWith","warn","getTagNameFromFile","mediaElement","createElement","id","objectFit","position","alt","videoElement","videoSource","type","autoplay","appendChild","configureVideoElement","prepareElement"],"sourceRoot":""}