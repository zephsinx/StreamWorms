{"version":3,"file":"main.241eb66ab9659193049a.js","mappings":"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","sources":["webpack://@zephsinx/streamerworm/./src/constants.js","webpack://@zephsinx/streamerworm/./src/medialist.js","webpack://@zephsinx/streamerworm/webpack/bootstrap","webpack://@zephsinx/streamerworm/./src/streamerworm.js"],"sourcesContent":["// StreamerWorm constants.\r\nexports.DefaultMinMinutes = 30;\r\nexports.DefaultMaxMinutes = 90;\r\nexports.DefaultMaxHeight = '25'; // Percentage value\r\nexports.DefaultMaxWidth = '25'; // Percentage value\r\n","// Array of image/video paths and their display duration.\r\n// Note: Image names must match values in /dist/media\r\nexports.MediaList = [\r\n    { path: 'media/worms-transparent.gif', durationMillis: 4410 },\r\n];","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId](module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\"use strict\";\r\n\r\n// Constants\r\nconst constants = require('./constants');\r\nconst media = require('./medialist');\r\n\r\n// Global defaults\r\nconst defaultMinMillis = constants.DefaultMinMinutes * 60 * 1000;\r\nconst defaultMaxMillis = constants.DefaultMaxMinutes * 60 * 1000;\r\n\r\n// Global values\r\nlet lastCorner = randomIntFromInterval(0, 3);\r\n\r\n// Get config settings\r\nconst config = getStreamerWormConfig();\r\n\r\n// Set default media to the first entry in the list\r\nconst mediaListElement = media.MediaList[0];\r\n\r\n// Build media element based on file extension\r\nconst tagName = getTagNameFromFile(mediaListElement.path);\r\nconst element = prepareElement(tagName, config);\r\n\r\n// Create and append media element to media div\r\nconst mediaDiv = document.getElementById(\"media-div\");\r\nmediaDiv.appendChild(element);\r\n\r\n// Initialize media loop\r\nplayMedia(element);\r\n\r\n//#region Media Methods\r\n\r\n// Shows and plays media after a random delay, then hides the media after durationMillis expires.\r\nfunction playMedia(element) {\r\n    // Skip delay between media plays when config.skipDelay == true\r\n    let delay = randomIntFromInterval(config.minDelay, config.maxDelay);\r\n    \r\n    // Display the image after the random delay expires\r\n    setTimeout(() => {\r\n        // Reset image source to replay in the case of a GIF\r\n        if (tagName === 'img') {\r\n            element.src = '';\r\n            element.src = mediaListElement.path;\r\n        }\r\n        // Restart video and play in the case of a WebM\r\n        else {\r\n            element.currentTime = 0;\r\n            element.play();\r\n        }\r\n        // Make media visible\r\n        element.style.visibility = 'visible';\r\n        \r\n        // Hide image/video after it plays for the desired duration, and requeue the media timer\r\n        setTimeout(() => {\r\n            element.style.visibility = 'hidden';\r\n            setPosition(element);\r\n            playMedia(element);\r\n        }, mediaListElement.durationMillis);\r\n        \r\n    }, delay);\r\n}\r\n\r\n// Returns a random integer between min and max (inclusive)\r\nfunction randomIntFromInterval(min, max) {\r\n    return Math.floor(Math.random() * (max - min + 1) + min)\r\n}\r\n\r\nfunction setPosition(element) {\r\n    let corner = randomIntFromInterval(0, 3);\r\n    while (lastCorner === corner) {\r\n        corner = randomIntFromInterval(0, 3);\r\n    }\r\n    lastCorner = corner;\r\n\r\n    element.style.top = '';\r\n    element.style.bottom = '';\r\n    element.style.left = '';\r\n    element.style.right = '';\r\n\r\n    switch (corner) {\r\n        // 0: top left\r\n        case 0:\r\n            element.style.top = '0px';\r\n            element.style.left = '0px';\r\n            break;\r\n        // 1: top right\r\n        case 1:\r\n            element.style.top = '0px';\r\n            element.style.right = '0px';\r\n            break;\r\n        // 2: bottom right\r\n        case 2:\r\n            element.style.bottom = '0px';\r\n            element.style.right = '0px';\r\n            break;\r\n        // 3: bottom left\r\n        case 3:\r\n            element.style.bottom = '0px';\r\n            element.style.left = '0px';\r\n            break;\r\n    }\r\n}\r\n\r\n//#endregion\r\n\r\n//#region StreamerWorm configuration methods\r\n\r\n// Parse URL parameters from URL\r\nfunction getStreamerWormConfig() {\r\n    // Get parameters from browser URL\r\n    let urlParams = new Proxy(new URLSearchParams(window.location.search), {\r\n        get: (searchParams, prop) => searchParams.get(prop || ''),\r\n    });\r\n\r\n    // todo: (param) Image display coordinates (where on the screen should it show up)\r\n    let skipDelay = parseBool(urlParams.skipDelay);\r\n    let maxDelayMillis = getDelayMillis(skipDelay, urlParams.max, defaultMaxMillis);\r\n    let minDelayMillis = getDelayMillis(skipDelay, urlParams.min, defaultMinMillis);\r\n    let maxHeight = isValidNumericValue(urlParams.maxHeight) ? urlParams.maxHeight : constants.DefaultMaxHeight;\r\n    let maxWidth = isValidNumericValue(urlParams.maxWidth) ? urlParams.maxWidth : constants.DefaultMaxWidth;\r\n    // let shouldRandomize = parseBool(urlParams.randomize);\r\n    // let slideshow = parseBool(urlParams.slideshow);\r\n    \r\n    let config = {\r\n        maxDelay: maxDelayMillis,         // The maximum delay between media plays (ignored if skipDelay is true)\r\n        minDelay: minDelayMillis,         // The minimum delay between media plays (ignored if skipDelay is true)\r\n        maxHeight: maxHeight,             // The maximum height the media should take up. Image will be resized to fit if larger.\r\n        maxWidth: maxWidth,               // The maximum width the media should take up. Image will be resized to fit if larger.\r\n        // shouldRandomize: shouldRandomize, // If the displayed media should be randomized from the media list (ignored if slideshow is false)\r\n        // slideshow: slideshow,             // If the displayed media should change on each loop\r\n    };\r\n    \r\n    return validateConfig(config);\r\n}\r\n\r\n// Validate and update config if invalid.\r\nfunction validateConfig(config) {\r\n    // minDelayMillis must be less than or equal to maxDelayMillis, else use defaults\r\n    if (config.maxDelayMillis < config.minDelayMillis)\r\n    {\r\n        config.maxDelayMillis = defaultMaxMillis;\r\n        config.minDelayMillis = defaultMinMillis;\r\n    }\r\n    \r\n    return config;\r\n}\r\n\r\n// Validate and calculate delay in milliseconds from params\r\nfunction getDelayMillis(skipDelay, delayMinutes, defaultDelay) {\r\n    if (skipDelay)\r\n        return 0;\r\n\r\n    return isValidNumericValue(delayMinutes) ? (delayMinutes * 60 * 1000) : defaultDelay;\r\n}\r\n\r\n// Check that provided string is a valid number and positive.\r\nfunction isValidNumericValue(numberString) {\r\n    return !isNaN(numberString) && !isNaN(parseFloat(numberString)) && parseFloat(numberString) > 0;\r\n}\r\n\r\n// Returns the value of a string as a boolean. Defaults to \"false\" if not a valid boolean\r\nfunction parseBool(boolString) {\r\n    return boolString === 'true';\r\n}\r\n\r\n//#endregion\r\n\r\n//#region Element Configuration\r\n\r\n// Configure element to display based on tagName\r\nfunction prepareElement(tagName, config) {\r\n    // Create img or video element based on tagName\r\n    let mediaElement = document.createElement(tagName);\r\n    mediaElement.id = 'rendered-media';\r\n    mediaElement.style.objectFit = 'contain';\r\n    mediaElement.style.maxHeight = config.maxHeight + '%';\r\n    mediaElement.style.maxWidth = config.maxWidth + '%';\r\n    mediaElement.style.position = 'absolute';\r\n    \r\n    switch (tagName) {\r\n        case 'img':\r\n            return configureImageElement(mediaElement);\r\n        case 'video':\r\n            return configureVideoElement(mediaElement);\r\n        default:\r\n            throw 'Tag name ' + tagName + ' not recognized';\r\n    }\r\n}\r\n\r\n// Get the appropriate element tag name from the media file extension\r\nfunction getTagNameFromFile(fileName) {\r\n    let tagName;\r\n    let fileExtension = fileName.slice((Math.max(0, fileName.lastIndexOf(\".\")) || Infinity) + 1);\r\n\r\n    switch (fileExtension) {\r\n        case 'apng':\r\n        case 'avif':\r\n        case 'gif':\r\n        case 'jpg':\r\n        case 'jpeg':\r\n        case 'jpe':\r\n        case 'jif':\r\n        case 'png':\r\n        case 'svg':\r\n        case 'jfif':\r\n        case 'webp':\r\n            tagName = 'img';\r\n            break;\r\n        case 'webm':\r\n            tagName = 'video';\r\n            break;\r\n        default:\r\n            throw 'File extension .' + fileExtension + ' is not yet supported';\r\n    }\r\n\r\n    return tagName;\r\n}\r\n\r\n// Set Image properties\r\nfunction configureImageElement(image) {\r\n    // todo: Configure image\r\n    return image;\r\n}\r\n\r\n// Set Video properties\r\nfunction configureVideoElement(videoElement) {\r\n    let videoSource = document.createElement('source');\r\n    videoSource.src = mediaListElement.path;\r\n    videoSource.type = 'video/webm';\r\n\r\n    // Note: autoplay only works in Chrome after a user has interacted with the DOM unless the muted tag is used\r\n    videoElement.autoplay = true;\r\n    // videoElement.muted = 'muted'; // Needed to autoplay in Chrome browser after Chrome 66\r\n    videoElement.appendChild(videoSource);\r\n\r\n    return videoElement;\r\n}\r\n\r\n//#endregion"],"names":["exports","DefaultMinMinutes","DefaultMaxMinutes","DefaultMaxHeight","DefaultMaxWidth","MediaList","path","durationMillis","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","undefined","module","__webpack_modules__","constants","media","defaultMinMillis","defaultMaxMillis","lastCorner","randomIntFromInterval","config","urlParams","Proxy","URLSearchParams","window","location","search","get","searchParams","prop","skipDelay","maxDelayMillis","minDelayMillis","validateConfig","maxDelay","getDelayMillis","max","minDelay","min","maxHeight","isValidNumericValue","maxWidth","getStreamerWormConfig","mediaListElement","tagName","fileName","fileExtension","slice","Math","lastIndexOf","Infinity","getTagNameFromFile","element","mediaElement","document","createElement","id","style","objectFit","position","videoElement","videoSource","src","type","autoplay","appendChild","configureVideoElement","prepareElement","floor","random","delayMinutes","defaultDelay","numberString","isNaN","parseFloat","getElementById","playMedia","delay","setTimeout","currentTime","play","visibility","corner","top","bottom","left","right","setPosition"],"sourceRoot":""}